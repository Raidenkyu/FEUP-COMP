options {
  LOOKAHEAD = 1;
  FORCE_LA_CHECK = true;
}

PARSER_BEGIN(jmm)
import java.io.*;

public
class rework {
 public
  static void main(String args[]) throws ParseException, Exception {
    FileReader fr = new FileReader(args[0]);
    jmm myProg = new jmm(fr);
    SimpleNode root = myProg.Start();  // devolve referência para o nó raiz da árvore
    root.dump("");                     // imprime no ecrã a árvore
  }

  // https://javacc.org/tutorials/errorrecovery
  void error_skipto(int kind) {
    ParseException e = generateParseException();  // generate the exception object.
    System.out.println(e.toString());             // print the error message
    Token t;
    do {
      t = getNextToken();
    } while (t.kind != kind);
    // The above loop consumes tokens all the way up to a token of
    // "kind".  We use a do-while loop rather than a while because the
    // current token is the one immediately before the erroneous token
    // (in our case the token immediately before what should have been
    // "if"/"while".
  }
}
PARSER_END(jmm)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

TOKEN: {
    // Keywords
    <PUBLIC: "public">
    |
    <STATIC: "static">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <NEW: "new">
    |
    <THIS: "this">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    // Builtin types
    <VOID: "void">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    // Operators
    <COMMA: ",">
    |
    <SEMICOLON: ";">
    |
    <EQUAL: "=">
    |
    <AND: "&">
    |
    <LT: "<">
    |
    <SUM: "+">
    |
    <SUB: "-">
    |
    <MUL: "*">
    |
    <DIV: "/">
    |
    <NOT: "!">
    |
    <POINT: ".">
    |
    // Special strings
    <MAIN: "main">
    |
    <STRING: "String">
    |
    <LENGTH: "length">
    |
    // Brackets
    <LEFTKEY: "{">
    |
    <RIGHTKEY: "}">
    |
    <LSB: "[">  // Left Square Bracket
    |
    <RSB: "]">  // Right Square Bracket
    |
    <LCB: "(">  // Left Curved Bracket
    |
    <RCB: ")">  // Right Curved Bracket
    |
    // Integer Literal (decimal | hexadecimal | binary)
    <INTEGERLITERAL: (((["+","-"])?(["0"-"9"])+)|("0x"(["0"-"9","a"-"f","A"-"F"])+)|("0b"(["0","1"])+))>
    |
    // Identifier
    <IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])*>
}

// *** Class
SimpleNode Start() : {}
{
  ClassDeclaration()<EOF> {
    return jjtThis;
  }
}

void ClassDeclaration() : {} {
<CLASS>
    <IDENTIFIER>
    (<EXTENDS><IDENTIFIER>)?
    <LEFTKEY>
    (ClassVarDeclaration())*
    (ClassMethodDeclaration())*
    <RIGHTKEY>
}

void ClassVarDeclaration() : {} {
  Type()<IDENTIFIER><SEMICOLON>
}

void ClassMethodDeclaration() : {} {
  <PUBLIC>(MainDeclaration() | MethodDeclaration())
}

// *** Methods Declarations
void MainDeclaration() #void : {} {
<STATIC>
    <VOID>
    <MAIN>
    <LCB>
    MainParameterList()
    <RCB>
    <LEFTKEY>
    MethodBody()  // * Found a slight problem with using ? here
    <RIGHTKEY>
}

void MethodDeclaration() : {} {
  Type() #MethodReturnType<IDENTIFIER> #MethodName<LCB>
  ParameterList() #MethodParameterList<RCB>
    <LEFTKEY> MethodBody()  // * Found a slight problem with using ? here
    <RETURN>
    Expression() #ReturnExpression<SEMICOLON><RIGHTKEY>
}

// *** Parameters
void Parameter() : {} {
  Type() #ParameterType<IDENTIFIER> #ParameterName
}

void ParameterList() : {} {
  (Parameter()(<COMMA> Parameter())*) ?
}

void MainParameterList() : {} {
<STRING> <LSB> <RSB> <IDENTIFIER>
}

// *** Types
void PrimitiveType() : {} {
  IntType() | <BOOLEAN>
}

void ClassType() : {} {
<IDENTIFIER>
}

void IntType() : {} {
  <INT>(<LSB><RSB>) ?
}

void Type() : {} {
  PrimitiveType() | ClassType()
}

// *** Method Body (previous VarThenStatement)
void MethodBody() : {} {
  PrimitiveType() VarName() MethodBody()
    // [int, boolean] Declaration of a variable of primitive type, then self-recurse
    | <IDENTIFIER> AssignmentOrDeclaration()
    // [identifier] Starting with an identifier, then self-recurse or more statements
    | (NonIdentifierStatement()(Statement())*)
    ?
  // [anything else] Block or literal statement, followed by more statements
}

void VarName() : {} {
<IDENTIFIER> <SEMICOLON>
}

void AssignmentOrDeclaration() : {} {
  VarName() MethodBody()                       // Declaration
    | IdentifierStatementTail()(Statement())*  // Assignment
}

void Assignment() : {} {
  (ArrayAccess()) ? AssignedValue()
}

void AssignedValue() : {} {
  <EQUAL> Expression()
}

// Access an array: [...]
void ArrayAccess() : {} {
<LSB> Expression() <RSB>
}

// *** Statements
void Statement() : {} {
  BlockStatement() | LineStatement()
}

void BlockStatement() : {} {
  BracedBlockStatement() | IfStatement() | WhileStatement()
}

void LineStatement() : {} {
  LiteralStatement() | IdentifierStatement()
}

void LiteralStatement() : {} {
  LiteralExpression()<SEMICOLON>
}

void IdentifierStatement() : {} {
  <IDENTIFIER> IdentifierStatementTail()
}

void IdentifierStatementTail() : {} {
  (Assignment())
    ? <SEMICOLON> | MemberAccess()(ExpressionTail1()) * <SEMICOLON> | (ExpressionTail1()) + <SEMICOLON>
}

void NonIdentifierStatement() : {} {
  BracedBlockStatement() | IfStatement() | WhileStatement() | LiteralStatement()
}

// An argument for any function call
void Argument() : {} {
  Expression()
}

// A list of arguments for any function call
void ArgumentList() : {} {
  (Argument()(<COMMA> Argument())*) ?
}

// Aceita: (1 + 2)[3]
// Aceita: true.length
// Aceita: 1;
// Não aceita: Call methods of same class, e.g:
//             find();

void BracedBlockStatement() : {} {
<LEFTKEY> (Statement())* <RIGHTKEY>
}

void IfStatement() : {} {
  <IF><LCB> Expression()<RCB> Statement()<ELSE> Statement()
}

void WhileStatement() : {} {
  <WHILE><LCB> Expression()<RCB> Statement()
}

// *** Term
void Term() #void : {} {
  LiteralTerm() | IdentifierTerm()
}

void LiteralTerm() : {} {
  <INTEGERLITERAL>(TermTail()) *  // ! COMPILER-INCORRECT WITH TAIL
    | <TRUE>(TermTail()) *        // ! COMPILER-INCORRECT WITH TAIL
    | <FALSE>(TermTail()) *       // ! COMPILER-INCORRECT WITH TAIL
    | <THIS>(TermTail()) * | <NEW> NewTerm()(TermTail()) * | <NOT> Term()
    | <LCB> Expression()<RCB>(TermTail())*
}

void NewTerm() : {} {
<INT> <LSB> Expression() <RSB>
    |
    <IDENTIFIER> <LCB> <RCB>
}

void IdentifierTerm() : {} {
  <IDENTIFIER>(TermTail())*
}

void TermTail() : {} {
  ArrayAccess() | MemberAccess()
}

void MemberAccess() : {} {
  <POINT> MemberField()
}

void MemberField() : {} {
  <LENGTH> | MethodCall()
}

void MethodCall() : {} {
<IDENTIFIER> <LCB> ArgumentList() <RCB>
}

// *** Expressions
void Expression() : {} {
  Term()(ExpressionTail1())*
}

void LiteralExpression() : {} {
  LiteralTerm()(ExpressionTail1())*
}

void IdentifierExpression() : {} {
  IdentifierTerm()(ExpressionTail1())*
}

void ExpressionTail1() #void : {} {
  OperatorPrecedence4() Term() | ExpressionTail2()
}

void ExpressionTail2() #void : {} {
  OperatorPrecedence9() Term() | ExpressionTail3()
}

void ExpressionTail3() #void : {} {
  OperatorPrecedence11() Term() | ExpressionTail4()
}

void ExpressionTail4() #void : {} {
  OperatorPrecedence12() Term()
}

// *** Operators
void Operator() #void : {} {
  <AND> #And
    // 4
    | <LT> #Lt
    // 9
    | <SUM> #Sum
    // 11
    | <SUB> #Sub
    // 11
    | <MUL> #Mul
    // 12
    | <DIV> #Div
  // 12
}

void OperatorPrecedence12() : {} {
  <MUL> #Mul | <DIV> #Div
}

void OperatorPrecedence11() : {} {
  <SUM> #Sum | <SUB> #Sub
}

void OperatorPrecedence9() : {} {
  <LT> #Lt
}

void OperatorPrecedence4() : {} {
  <AND> #And
}
