options {
    LOOKAHEAD = 1;
    FORCE_LA_CHECK = true;
}

PARSER_BEGIN(expression)
import java.io.*;

public class expression {
    public static void main(String args[]) throws ParseException, Exception {
        FileReader fr = new FileReader(args[0]);
        expression myProg = new expression(fr);
        SimpleNode root = myProg.Start();
        root.dump("");
    }
}
PARSER_END(expression)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

TOKEN: {
    // Keywords
    <PUBLIC: "public">
    |
    <STATIC: "static">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <NEW: "new">
    |
    <THIS: "this">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    // Builtin types
    <VOID: "void">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    // Operators
    <COMMA: ",">
    |
    <SEMICOLON: ";">
    |
    <EQUAL: "=">
    |
    <AND: "&&">
    |
    <LT: "<">
    |
    <SUM: "+">
    |
    <SUB: "-">
    |
    <MUL: "*">
    |
    <DIV: "/">
    |
    <NOT: "!">
    |
    <POINT: ".">
    |
    // Special strings
    <MAIN: "main">
    |
    <STRING: "String">
    |
    <LENGTH: "length">
    |
    // Brackets
    <LEFTKEY: "{">
    |
    <RIGHTKEY: "}">
    |
    <LSB: "[">  // Left Square Bracket
    |
    <RSB: "]">  // Right Square Bracket
    |
    <LCB: "(">  // Left Curved Bracket
    |
    <RCB: ")">  // Right Curved Bracket
    |
    // Integer Literal (decimal | hexadecimal | binary)
    <INTEGERLITERAL: (((["+","-"])?(["0"-"9"])+)|("0x"(["0"-"9","a"-"f","A"-"F"])+)|("0b"(["0","1"])+))>
    |
    // Identifier
    <IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])*>
    | <ARR: "@">
}

void Integer() : {Token t1;}
{
    t1 = <INTEGERLITERAL>
    {jjtThis.val = t1.image;}
}

void MethodName() : {Token t1;}
{
    t1 = <IDENTIFIER>
    {jjtThis.val = t1.image;}
}

void ClassType() : {Token t1;}
{
    t1 = <IDENTIFIER>
    {jjtThis.val = t1.image;}
}

void Identifier() : {Token t1;}
{
    t1 = <IDENTIFIER>
    {jjtThis.val = t1.image;}
}

SimpleNode Start() : {}
{
    ClassDeclaration()
    {return jjtThis;}
}

// *** Expression
void Expression() #void : {}
{
    Term1() (Op1())*
}

void ExpressionTail() #void : {}
{
    (Op4())* (Op3())* (Op2())* (Op1())*
}

void LiteralExpression() #void : {}
{
    LiteralTerm4() ExpressionTail()
}

void IdentifierExpression() #void : {}
{
    IdentifierTerm4() ExpressionTail()
}

void Term1() #void : {}
{
    Term2() (Op2())*
}

void Term2() #void : {}
{
    Term3() (Op3())*
}

void Term3() #void : {}
{
    Term4() (Op4())*
}

void Term4() #void : {}
{
    Integer() (TermTail())*
    |
    Identifier() (TermTail())*
    |
    (<TRUE> #True) (TermTail())*
    |
    (<FALSE> #False) (TermTail())*
    |
    (<THIS> #This) (TermTail())*
    |
    (<LCB> Expression() <RCB>) (TermTail())*
    |
    <NEW> NewTerm()
    |
    <NOT> Term4() #NOT(1)
}

void Op1() #void : {}
{
    <AND> Term1() #AND(2)
}

void Op2() #void : {}
{
    <LT> Term2() #LT(2)
}

void Op3() #void : {}
{
    <SUM> Term3() #SUM(2)
    |
    <SUB> Term3() #SUB(2)
}

void Op4() #void : {}
{
    <MUL> Term4() #MUL(2)
    |
    <DIV> Term4() #DIV(2)
}

void TermTail() #void : {}
{
    ArrayAccess()
    |
    ObjectAccess()
}

void ArrayAccess() #void : {}
{
    <LSB> Expression() <RSB> #Bracket(2)
}

void ObjectAccess() #void : {}
{
    <POINT> ObjectAccessTail()
}

void ObjectAccessTail() #void : {}
{
    <LENGTH> #Length(1)
    |
    MethodName() ArgumentList() #Call(3)
}

void ArgumentList() : {}
{
    <LCB> (Expression() (<COMMA> Expression())*)? <RCB>
}

void NewTerm() #void : {}
{
    <INT> <LSB> Expression() <RSB> #NewIntArray(1)
    |
    ClassType() <LCB> <RCB> #NewClass(1)
}

void LiteralTerm4() #void : {}
{
    Integer() (TermTail())*
    |
    (<TRUE> #True) (TermTail())*
    |
    (<FALSE> #False) (TermTail())*
    |
    (<THIS> #This) (TermTail())*
    |
    (<LCB> Expression() <RCB>) (TermTail())*
    |
    <NEW> NewTerm()
    |
    <NOT> Term4() #NOT(1)
}

void IdentifierTerm4() #void : {}
{
    Identifier() (TermTail())*
}

// *** Statements
// * Statement Types:
//   * BlockStatement(*)  { ... }
//   * IfElseStatement(3) if (Condition) TrueBranch else ElseBranch
//   * WhileStatement(2)  while (Condition) LoopBody
//   * PlainStatement(1)  Expression
//   * Assignment(2)      Target = Value
void Statement() #void : {}
{
    BlockStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    LineStatement()
}

void BlockStatement() : {}
{
    <LEFTKEY> (Statement())* <RIGHTKEY>
}

void IfElseStatement() : {}
{
    <IF> <LCB> Expression() <RCB> //#Condition(1)
    Statement() //#TrueBranch(1)
    <ELSE> Statement() //#FalseBranch(1)
}

void WhileStatement() : {}
{
    <WHILE> <LCB> Expression() <RCB> //#Condition(1)
    Statement() //#LoopBody(1)
}

void LineStatement() #void : {}
{
    LiteralLineStatement()
    |
    IdentifierStatement()
}

void LiteralLineStatement() #void : {}
{
    LiteralExpression() <SEMICOLON> #PlainStatement(1)
}

void IdentifierStatement() #void : {}
{
    Identifier() IdentifierStatementTail()
}

void IdentifierStatementTail() #void : {}
{
    (<EQUAL> Expression() #Assignment(2)
    |
    ArrayAccess() (<EQUAL> Expression() #Assignment(2))?
    |
    ObjectAccess() ExpressionTail()
    |
    ExpressionTail())
    <SEMICOLON> #PlainStatement(1)
}

void LiteralStatement() #void : {}
{
    BlockStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    LiteralLineStatement()
}

// *** Types
void Type() #void : {}
{
    PrimitiveType()
    |
    ClassType()
}

void PrimitiveType() #void : {}
{
    IntType()
    |
    <BOOLEAN> #Boolean
    |
    <STRING> #String
}

void IntType() #void : {}
{
   (<INT> #Int) (<LSB> <RSB> #IntArray(1))?
}

// *** Method Body (Declarations and Statements)
void MethodBody() #void : {}
{
    PrimitiveType() Identifier() #VariableDeclaration(2)
    <SEMICOLON> MethodBody()
    |
    Identifier() AssignmentOrDeclaration()
    |
    (LiteralStatement() (Statement())*)?
}

void AssignmentOrDeclaration() #void : {}
{
    Identifier() #VariableDeclaration(2) <SEMICOLON> MethodBody()
    |
    IdentifierStatementTail() (Statement())*
}

// *** Parameters
void Parameter(): {}
{
    Type() Identifier()
}

void ParameterList(): {}
{
    (Parameter() (<COMMA> Parameter())*)?
}

void MainParameterList(): {}
{
    <STRING> <LSB> <RSB> Identifier()
}

// *** Methods
void MainDeclaration() #void : {}
{
    //<PUBLIC>
    <STATIC>
    <VOID>
    <MAIN>
    <LCB>
    MainParameterList()
    <RCB>
    <LEFTKEY>
    MethodBody() #MethodBody
    <RIGHTKEY>
}

void MethodDeclaration() #void : {}
{
    //<PUBLIC>
    Type() #MethodReturnType
    MethodName()
    <LCB>
    ParameterList()
    <RCB>
    <LEFTKEY>
    MethodBody() #MethodBody
    <RETURN>
    Expression() #ReturnExpression
    <SEMICOLON>
    <RIGHTKEY>
}

// *** Class

void ClassDeclaration() : {}
{
    <CLASS>
    ClassType()
    (<EXTENDS> ClassType() #Extends(1))?
    <LEFTKEY>
    (ClassVarDeclaration())*
    (ClassMethodDeclaration())*
    <RIGHTKEY>
}

void ClassVarDeclaration() : {}
{
    Type() Identifier() <SEMICOLON>
}

void ClassMethodDeclaration() : {}
{
    <PUBLIC> (MainDeclaration() | MethodDeclaration())
}

// TODO: What to do with variables named "main", "length".
// TODO: What to do with types named "main", "length", "String".
