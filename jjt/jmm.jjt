// clang-format off
options {
    LOOKAHEAD = 1;
    FORCE_LA_CHECK = true;
    TRACK_TOKENS = true;
}

PARSER_BEGIN(jmm)
import java.io.*;
import java.util.regex.*;

public class jmm {
    public static int numberRecoveries = 0;

    public static Boolean has_error = false;
    public static String file;

    public static void main(String args[]) throws FileNotFoundException, ParseException {
        FileReader fr = new FileReader(args[0]);
        ParseException.file=args[0];
        jmm myProg = new jmm(fr);
        jmm.numberRecoveries = Integer.parseInt(args[1]);
        try {
            SimpleNode root = myProg.Program();
            //If there has been at least one error it doesn't print the tree
            if(!jmm.has_error)root.dump("");
        } catch (ParseException e) {
            e.printStackTrace();
        }
    }
}
PARSER_END(jmm)

SKIP: {
    " " | "\r" | "\t" | "\n"
}

TOKEN: {
    // Keywords
    <PUBLIC: "public">
    |
    <STATIC: "static">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <NEW: "new">
    |
    <THIS: "this">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    // Builtin types
    <VOID: "void">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    // Operators
    <COMMA: ",">
    |
    <SEMICOLON: ";">
    |
    <EQUAL: "=">
    |
    <AND: "&&">
    |
    <LT: "<">
    |
    <SUM: "+">
    |
    <SUB: "-">
    |
    <MUL: "*">
    |
    <DIV: "/">
    |
    <NOT: "!">
    |
    <POINT: ".">
    |
    // Special strings
    <MAIN: "main">
    |
    <STRING: "String">
    |
    <LENGTH: "length">
    |
    // Brackets
    <LEFTKEY: "{">
    |
    <RIGHTKEY: "}">
    |
    <LSB: "[">  // Left Square Bracket
    |
    <RSB: "]">  // Right Square Bracket
    |
    <LCB: "(">  // Left Curved Bracket
    |
    <RCB: ")">  // Right Curved Bracket
    |
    // Integer Literal (decimal | hexadecimal | binary)
    <INTEGERLITERAL: (((["+","-"])?(["0"-"9"])+)|("0x"(["0"-"9","a"-"f","A"-"F"])+)|("0b"(["0","1"])+))>
    |
    // Identifier
    <IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])*>
    |
    <ARR: "@">
}

SimpleNode Program() : {}
{
    ClassDeclaration() (<ARR> ClassDeclaration())*
    {return jjtThis;}
}

// *** Terminals with Values
void Integer() : {Token token;}
{
    token = <INTEGERLITERAL>
    {jjtThis.jjtSetVal(token.image);}
}

void MethodName() : {Token token;}
{
    token = <IDENTIFIER>
    {jjtThis.jjtSetVal(token.image);}
}

void ClassType() : {Token token;}
{
    token = <IDENTIFIER>
    {jjtThis.jjtSetVal(token.image);}
}

void Identifier() : {Token token;}
{
    token = <IDENTIFIER>
    {jjtThis.jjtSetVal(token.image);}
}

// *** Expression
void Expression() #void : {}
{
    Term1() (Op1())*
}

void ExpressionTail() #void : {}
{
    (Op4())* (Op3())* (Op2())* (Op1())*
}

void LiteralExpression() #void : {}
{
    LiteralTerm4() ExpressionTail()
}

void IdentifierExpression() #void : {}
{
    IdentifierTerm4() ExpressionTail()
}

// *** Term
void Term1() #void : {}
{
    Term2() (Op2())*
}

void Term2() #void : {}
{
    Term3() (Op3())*
}

void Term3() #void : {}
{
    Term4() (Op4())*
}

void Term4() #void : {}
{
  LiteralTerm4()
  |
  IdentifierTerm4()
}

void LiteralTerm4() #void : {}
{
    Integer() TermTail()
    |
    (<TRUE> #True) TermTail()
    |
    (<FALSE> #False) TermTail()
    |
    (<THIS> #This) TermTail()
    |
    (<LCB> Expression() <RCB>) TermTail()
    |
    <NEW> NewTerm() TermTail()
    |
    NOT()
}

void IdentifierTerm4() #void : {}
{
    Identifier() TermTail()
}

void TermTail() #void : {}
{
    (ArrayAccess() | ObjectAccess())*
}

void ArrayAccess() #void : {}
{
    (<LSB> Expression() <RSB>) #Bracket(2)
}

void ObjectAccess() #void : {}
{
    <POINT> ObjectAccessTail()
}

void ObjectAccessTail() #void : {}
{
    <LENGTH> #Length(1)
    |
    MethodName() <LCB> ArgumentList() <RCB> #Call(3)
}

void ArgumentList() : {}
{
    (Expression() (<COMMA> Expression())*)?
}

void NewTerm() #void : {}
{
    <INT> <LSB> Expression() <RSB> #NewIntArray(1)
    |
    ClassType() <LCB> <RCB> #NewClass(1)
}

// *** Operators
void Op1() #void : {}
{
    <AND> Term1() #AND(2)
}

void Op2() #void : {}
{
    <LT> Term2() #LT(2)
}

void Op3() #void : {}
{
    <SUM> Term3() #SUM(2)
    |
    <SUB> Term3() #SUB(2)
}

void Op4() #void : {}
{
    <MUL> Term4() #MUL(2)
    |
    <DIV> Term4() #DIV(2)
}

void NOT() : {}
{
    <NOT> Term4()
}

// *** Statements
// * Statement Types:
//   * BlockStatement(*)  { ... }
//   * IfElseStatement(3) if (Condition) TrueBranch else ElseBranch
//   * WhileStatement(2)  while (Condition) LoopBody
//   * PlainStatement(1)  Expression
//   * Assignment(2)      Target = Value
void Statement() #void : {}
{
    BlockStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    LineStatement()
}

void BlockStatement() : {}
{
    <LEFTKEY> (Statement())* <RIGHTKEY>
}

void IfElseStatement() : {}
{
    <IF> <LCB> Expression() <RCB> //#Condition(1)
    Statement() //#TrueBranch(1)
    <ELSE> Statement() //#FalseBranch(1)
}

void WhileStatement() : {}
{
    try { <WHILE> <LCB> }
    catch (ParseException e) {jmm.has_error=true;System.out.println(e.toString()); 
        e.advance(); }

    try { Expression()
        try { <RCB> }
        catch (ParseException e) {jmm.has_error=true;System.out.println(e.toString());
            e.advance(); } }
    catch (ParseException e) {jmm.has_error=true;System.out.println(e.toString()); 
        e.skipto(new int[]{RCB, IF, WHILE, LEFTKEY}).consumeif(RCB); }

    try { Statement() }
    catch (ParseException e) {jmm.has_error=true;System.out.println(e.toString()); 
        e.skipto(new int[]{RIGHTKEY, SEMICOLON}).consume(); }
}

void LineStatement() #void : {}
{
    LiteralLineStatement()
    |
    IdentifierStatement()
}

// Expression ;   FOR NON IDENTIFIERS
void LiteralLineStatement() #void : {}
{
    LiteralExpression() <SEMICOLON> #PlainStatement(1)
}

void IdentifierStatement() #void : {}
{
    Identifier() IdentifierStatementTail()
}

// Identifier = Expression ;
// Identifier [ Expression ] = Expression ;
// Expression ;   FOR IDENTIFIERS
void IdentifierStatementTail() #void : {}
{
    (<EQUAL> Expression() #Assignment(2)
    |
    ArrayAccess() ArrayAccessIdentifierStatementTail()
    |
    ObjectAccess() TermTail() ExpressionTail())?
    <SEMICOLON> #PlainStatement(1)
}

void ArrayAccessIdentifierStatementTail() #void : {}
{
    <EQUAL> Expression() #Assignment(2)
    |
    TermTail() ExpressionTail()
}

void LiteralStatement() #void : {}
{
    BlockStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    LiteralLineStatement()
}

// *** Types
void Type() #void : {}
{
    PrimitiveType()
    |
    ClassType()
}

void PrimitiveType() #void : {}
{
    IntType()
    |
    <BOOLEAN> #Boolean
    |
    <STRING> #String
}

void IntType() #void : {}
{
   (<INT> #Int) (<LSB> <RSB> #IntArray(1))?
}

// *** Method Body (Declarations and Statements)
void MethodBody() #void : {}
{
    PrimitiveType() Identifier() #VariableDeclaration(2)
    <SEMICOLON> MethodBody()
    |
    Identifier() AssignmentOrDeclaration()
    |
    (LiteralStatement() (Statement())*)?
}

void AssignmentOrDeclaration() #void : {}
{
    Identifier() <SEMICOLON> #VariableDeclaration(2) MethodBody()
    |
    IdentifierStatementTail() (Statement())*
}

// *** Parameters
void Parameter(): {}
{
    Type() Identifier()
}

void ParameterList(): {}
{
    (Parameter() (<COMMA> Parameter())*)?
}

void MainParameterList(): {}
{
    <STRING> <LSB> <RSB> Identifier()
}

// *** Methods
void MainDeclaration() #void : {}
{
    //<PUBLIC>
    <STATIC>
    <VOID>
    <MAIN>
    <LCB>
    MainParameterList()
    <RCB>
    <LEFTKEY>
    MethodBody() #MethodBody
    <RIGHTKEY>
}

void MethodDeclaration() #void : {}
{
    //<PUBLIC>
    Type() //#MethodReturnType
    MethodName()
    <LCB>
    ParameterList()
    <RCB>
    <LEFTKEY>
    MethodBody() #MethodBody
    ReturnStatement()
    <RIGHTKEY>
}

void ReturnStatement() : {}
{
    <RETURN> Expression() <SEMICOLON>
}

// *** Class
void ClassDeclaration() : {}
{
    ClassHeader()
    ClassBody()
}

void ClassHeader() : {}
{
    <CLASS> ClassType() (Extends())?
}

void Extends() : {}
{
    <EXTENDS> ClassType()
}

void ClassBody() : {}
{
    <LEFTKEY>
    (ClassVarDeclaration())*
    (ClassMethodDeclaration())*
    <RIGHTKEY>
}

void ClassVarDeclaration() : {}
{
    Type() Identifier() <SEMICOLON>
}

void ClassMethodDeclaration() : {}
{
    <PUBLIC> (MainDeclaration() | MethodDeclaration())
}

// TODO: What to do with variables named "main", "length".
// TODO: What to do with types named "main", "length", "String".
// DONE: Add begin and end lines/columns (ranges) to output AST

/**
 * TODO: Range decisions:
 *  1. Should ClassHeader() include 'class'? [YES]
 *  2. Should Extends() include 'extends'? [YES]
 *  3. Should ClassBody() include '{' and '}'? [YES]
 *  4. Should ClassMethodDeclaration() include 'public'? [YES]
 *  4.1. Distinction between method and main? [NO]
 *  5. Should ArgumentList()/[Main]ParameterList() include '(' and ')'? [NO]
 *  6. Should NOT() include '!'? [YES]
 *  7. Should ReturnStatement() include 'return'? [YES]
 *  8. Should ReturnStatement() include ';'? [YES]
 *  ...
 */

// Keyword: one of
// abstract   continue   for          new         switch
// assert     default    if           package     synchronized
// boolean    do         goto         private     this
// break      double     implements   protected   throw
// byte       else       import       public      throws
// case       enum       instanceof   return      transient
// catch      extends    int          short       try
// char       final      interface    static      void
// class      finally    long         strictfp    volatile
// const      float      native       super       while
