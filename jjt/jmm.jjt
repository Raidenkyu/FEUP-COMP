options
{
 LOOKAHEAD=1;
 FORCE_LA_CHECK=true;
}

PARSER_BEGIN(jmm)
import java.io.*;

public class jmm
{
    public static void main(String args[]) throws ParseException,Exception {
        FileReader fr = new FileReader(args[0]);
        jmm myProg = new jmm(fr);
        SimpleNode root = myProg.Start(); // devolve referência para o nó raiz da árvore
        root.dump(""); // imprime no ecrã a árvore
    }

    //https://javacc.org/tutorials/errorrecovery
    void error_skipto(int kind) {
        ParseException e = generateParseException();  // generate the exception object.
        System.out.println(e.toString());  // print the error message
        Token t;
        do {
        t = getNextToken();
        } while (t.kind != kind);
        // The above loop consumes tokens all the way up to a token of
        // "kind".  We use a do-while loop rather than a while because the
        // current token is the one immediately before the erroneous token
        // (in our case the token immediately before what should have been
        // "if"/"while".
    }
}
PARSER_END(jmm)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

TOKEN: {
    // Keywords
    <PUBLIC: "public">
    |
    <STATIC: "static">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <NEW: "new">
    |
    <THIS: "this">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    // Builtin types
    <VOID: "void">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    // Operators
    <COMMA: ",">
    |
    <SEMICOLON: ";">
    |
    <EQUAL: "=">
    |
    <AND: "&">
    |
    <LT: "<">
    |
    <SUM: "+">
    |
    <SUB: "-">
    |
    <MUL: "*">
    |
    <DIV: "/">
    |
    <NOT: "!">
    |
    <POINT: ".">
    |
    // Special strings
    <MAIN: "main">
    |
    <STRING: "String">
    |
    <LENGTH: "length">
    |
    // Brackets
    <LEFTKEY: "{">
    |
    <RIGHTKEY: "}">
    |
    <LSB: "[">  // Left Square Bracket
    |
    <RSB: "]">  // Right Square Bracket
    |
    <LCB: "(">  // Left Curved Bracket
    |
    <RCB: ")">  // Right Curved Bracket
    |
    // Integer Literal (decimal | hexadecimal | binary)
    <INTEGERLITERAL: (((["+","-"])?(["0"-"9"])+)|("0x"(["0"-"9","a"-"f","A"-"F"])+)|("0b"(["0","1"])+))>
    |
    // Identifier
    <IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])*>
}

// *** Class
SimpleNode Start() : {}
{
    ClassDeclaration()
    <EOF>
    {return jjtThis;}
}

void ClassDeclaration(): {}
{
    <CLASS>
    <IDENTIFIER>
    (<EXTENDS><IDENTIFIER>)?
    <LEFTKEY>
    (ClassVarDeclaration())*
    (ClassMethodDeclaration())*
    <RIGHTKEY>
}

void ClassVarDeclaration() : {}
{
    Type()
    <IDENTIFIER>
    <SEMICOLON>
}

void ClassMethodDeclaration(): {}
{
    <PUBLIC>
    (MainDeclaration() | MethodDeclaration())
}

// *** Methods Declarations
void MainDeclaration(): {}
{
    <STATIC>
    <VOID>
    <MAIN>
    <LCB>
    MainParameterList()
    <RCB>
    <LEFTKEY>
    MethodBody()    // * Found a slight problem with using ? here
    <RIGHTKEY>
}

void MethodDeclaration(): {}
{
    Type()                #MethodReturnType
    <IDENTIFIER>          #MethodName
    <LCB>
    ParameterList()       #MethodParameterList
    <RCB>
    <LEFTKEY>
    MethodBody()    // * Found a slight problem with using ? here
    <RETURN>
    Expression()          #ReturnExpression
    <SEMICOLON>
    <RIGHTKEY>
}

// *** Parameters
void Parameter(): {}
{
    Type()                #ParameterType
    <IDENTIFIER>          #ParameterName
}

void ParameterList(): {}
{
    (Parameter() (<COMMA> Parameter())*)?
}

void MainParameterList(): {}
{
    <STRING> <LSB> <RSB> <IDENTIFIER>
}

// *** Types
void PrimitiveType(): {}
{
    IntType()
    |
    <BOOLEAN>
}

void ClassType(): {}
{
    <IDENTIFIER>
}

void IntType(): {}
{
    <INT> (<LSB> <RSB>)?
}

void Type(): {}
{
    PrimitiveType() | ClassType()
}

// *** Method Body (previous VarThenStatement)
void MethodBody(): {}
{
    PrimitiveType() VarName() MethodBody()
    // [int, boolean] Declaration of a variable of primitive type, then self-recurse
    |
    <IDENTIFIER> AssignmentOrDeclaration()
    // [identifier] Starting with an identifier, then self-recurse or more statements
    |
    (NonIdentifierStatement() (Statement())*)?
    // [anything else] Block or literal statement, followed by more statements
}

void VarName(): {}
{
    <IDENTIFIER> <SEMICOLON>
}

void AssignmentOrDeclaration(): {}
{
    VarName() MethodBody() // Declaration
    |
    IdentifierStatementTail() (Statement())* // Assignment
}

void Assignment(): {}
{
    (ArrayAccess())? AssignedValue()
}

void AssignedValue(): {}
{
    <EQUAL> Expression()
}

// Access an array: [...]
void ArrayAccess(): {}
{
    <LSB> Expression() <RSB>
}

// *** Statements
void Statement(): {}
{
    BlockStatement()
    |
    LineStatement()
}

void BlockStatement(): {}
{
    BracedBlockStatement()
    |
    IfStatement()
    |
    WhileStatement()
}

void LineStatement(): {}
{
    LiteralStatement()
    |
    IdentifierStatement()
}

void LiteralStatement(): {}
{
    LiteralExpression() <SEMICOLON>
}

void IdentifierStatement(): {}
{
    <IDENTIFIER> IdentifierStatementTail()
}

void IdentifierStatementTail(): {}
{
    (Assignment())? <SEMICOLON>
    |
    MemberAccess() (ExpressionTail())? <SEMICOLON>
    |
    ExpressionTail() <SEMICOLON>
}

void NonIdentifierStatement(): {}
{
    BracedBlockStatement()
    |
    IfStatement()
    |
    WhileStatement()
    |
    LiteralStatement()
}

// *** Expressions
void Expression(): {}
{
    Term() (ExpressionTail())?
}

void LiteralExpression(): {}
{
    LiteralTerm() (ExpressionTail())?
}

void IdentifierExpression(): {}
{
    IdentifierTerm() (ExpressionTail())?
}

void ExpressionTail(): {}
{
    (ExpressionOperator() Term())+
}

void ExpressionOperator(): {}
{
    <AND> | <LT> | <SUM> | <SUB> | <MUL> | <DIV>
}

// *** Term
void Term(): {}
{
    LiteralTerm()
    |
    IdentifierTerm()
}

void LiteralTerm(): {}
{
    <INTEGERLITERAL> (TermTail())* // ! COMPILER-INCORRECT WITH TAIL
    |
    <TRUE> (TermTail())* // ! COMPILER-INCORRECT WITH TAIL
    |
    <FALSE> (TermTail())* // ! COMPILER-INCORRECT WITH TAIL
    |
    <THIS> (TermTail())*
    |
    <NEW> NewTerm() (TermTail())*
    |
    <NOT> Term()
    |
    <LCB> Expression() <RCB> (TermTail())*
}

void NewTerm(): {}
{
    <INT> <LSB> Expression() <RSB>
    |
    <IDENTIFIER> <LCB> <RCB>
}

void IdentifierTerm(): {}
{
    <IDENTIFIER> (TermTail())*
}

void TermTail(): {}
{
    ArrayAccess()
    |
    MemberAccess()
}

void MemberAccess(): {}
{
    <POINT> MemberField()
}

void MemberField(): {}
{
    <LENGTH>
    |
    MethodCall()
}

void MethodCall(): {}
{
    <IDENTIFIER> <LCB> ArgumentList() <RCB>
}

// An argument for any function call
void Argument(): {}
{
    Expression()
}

// A list of arguments for any function call
void ArgumentList(): {}
{
    (Argument() (<COMMA> Argument())*)?
}

// Aceita: (1 + 2)[3]
// Aceita: true.length
// Aceita: 1;
// Não aceita: Call methods of same class, e.g:
//             find();



void BracedBlockStatement(): {}
{
    <LEFTKEY> (Statement())* <RIGHTKEY>
}

void IfStatement(): {}
{
    <IF> <LCB> Expression() <RCB> Statement() <ELSE> Statement()
}

void WhileStatement(): {}
{
    <WHILE> <LCB> Expression() <RCB> Statement()
}
