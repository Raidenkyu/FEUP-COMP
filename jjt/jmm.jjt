options
{
 LOOKAHEAD=3;
 FORCE_LA_CHECK=true;
}

PARSER_BEGIN(jmm)

public class jmm
{
    public static void main(String args[]) throws ParseException {
        jmm myProg = new jmm(System.in);
        SimpleNode root = myProg.Start(); // devolve referência para o nó raiz da árvore
        root.dump(""); // imprime no ecrã a árvore
    }
    //https://javacc.org/tutorials/errorrecovery
    void error_skipto(int kind) {
        ParseException e = generateParseException();  // generate the exception object.
        System.out.println(e.toString());  // print the error message
        Token t;
        do {
        t = getNextToken();
        } while (t.kind != kind);
        // The above loop consumes tokens all the way up to a token of
        // "kind".  We use a do-while loop rather than a while because the
        // current token is the one immediately before the erroneous token
        // (in our case the token immediately before what should have been
        // "if"/"while".
    }
}
PARSER_END(jmm)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

TOKEN: {
    <INTEGERLITERAL: (((["+","-"])?(["0"-"9"])+)|("0x"(["0"-"9","a"-"f","A"-"F"])+)|("0b"(["0","1"])+))>
    |
    <PUBLIC: "public">
    |
    <STATIC: "static">
    |
    <VOID: "void">
    |
    <MAIN: "main">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    <STRING: "String">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <NEW: "new">
    |
    <THIS: "this">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    <LENGTH: "length">
    |
    <IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])*>
    |
    <LEFTKEY: "{">
    |
    <RIGHTKEY: "}">
    |
    <LSB: "[">  // Left Square Bracket
    |
    <RSB: "]">  // Right Square Bracket
    |
    <COMMA: ",">
    |
    <SEMICOLON: ";">
    |
    <LCB: "(">  // Left Curved Bracket
    |
    <RCB: ")">  // Right Curved Bracket
    |
    <EQUAL: "=">
    |
    <AND: "&&">
    |
    <LT: "<">
    |
    <SUM: "+">
    |
    <SUB: "-">
    |
    <MUL: "*">
    |
    <DIV: "/">
    |
    <EXC: "!">
    |
    <POINT: ".">
}

SimpleNode Start(): {}
{
    ClassDeclaration()<EOF> {return jjtThis;}
}

void ClassDeclaration(): {} 
{
    <CLASS> 
    <IDENTIFIER>
    (<EXTENDS><IDENTIFIER>)?
    <LEFTKEY>
    (VarDeclaration())*
    (Declaration())*
    <RIGHTKEY>
}

void Declaration(): {}
{
    <PUBLIC>(MainDeclaration() | MethodDeclaration())
}

void VarDeclaration(): {}
{
    Type()
    <IDENTIFIER>
    <SEMICOLON>
}   

void MainDeclaration(): {}
{
    <STATIC>
    <VOID>
    <MAIN>
    <LCB>
    <STRING>
    <LSB>
    <RSB>
    <IDENTIFIER>
    <RCB>
    <LEFTKEY>
    (VarDeclaration())*
    (Statement())*
    <RIGHTKEY>
}

void MethodDeclaration(): {}
{
    Type()
    <IDENTIFIER>
    <LCB>
    (Type()<IDENTIFIER>(<COMMA>Type()<IDENTIFIER>)*)?   
    <RCB>
    <LEFTKEY>
    (VarDeclaration())*
    (Statement())*
    <RETURN>
    Expression()
    <SEMICOLON>
    <RIGHTKEY>
}

void Type(): {}
{
    Int()
    |
    <BOOLEAN>
    |
    <IDENTIFIER>
}

void Int(): {}
{
    <INT>(<LSB><RSB>)?
}

void Statement() : {}
{
    <LEFTKEY>
    (Statement())*
    <RIGHTKEY>
    |
    <IF><LCB>Expression()<RCB>Statement()<ELSE>Statement()
    |
    <WHILE><LCB>Expression()<RCB>Statement()
    |
    Expression()<SEMICOLON>
    |
    <IDENTIFIER><EQUAL>Expression()<SEMICOLON>
    |
    <IDENTIFIER><LSB>Expression()<RSB><EQUAL>Expression()<SEMICOLON>
}

void Expression() : {}
{
    ExpressionTerminals()(ExpressionL())?
}

void ExpressionL(): {}
{
    (<AND>|<LT>|<SUM>|<SUB>|<MUL>|<DIV>)Expression()
    |
    <LSB>Expression()<RSB>
    |
    Point()
}

void Point(): {}
{
    <POINT>AfterPoint()
}

void AfterPoint(): {}
{
    <LENGTH>
    |
    <IDENTIFIER><LCB>(Expression() (<COMMA>Expression())*)<RCB>
}

void New(): {} 
{
    <NEW>AfterNew()
}

void AfterNew(): {} 
{
    <INT><LSB>Expression()<RSB>
    |
    <IDENTIFIER><LCB><RCB>
}

void ExpressionTerminals(): {}
{
    <INTEGERLITERAL>
    |
    <TRUE>
    |
    <FALSE>
    |
    <THIS>
    |
    New()
    |
    <EXC>Expression()
    |
    <LCB>Expression()<RCB>
    |
    <IDENTIFIER>
}


