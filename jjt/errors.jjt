options {
    LOOKAHEAD = 1;
    FORCE_LA_CHECK = true;
}

PARSER_BEGIN(expression)
import java.io.*;

public class expression {
    public static void main(String args[]) throws ParseException, Exception {
        FileReader fr = new FileReader(args[0]);
        expression myProg = new expression(fr);
        SimpleNode root = myProg.Start();
        root.dump("");
    }
}
PARSER_END(expression)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

TOKEN: {
    // Keywords
    <PUBLIC: "public">
    |
    <STATIC: "static">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <NEW: "new">
    |
    <THIS: "this">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    // Builtin types
    <VOID: "void">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    // Operators
    <COMMA: ",">
    |
    <SEMICOLON: ";">
    |
    <EQUAL: "=">
    |
    <AND: "&&">
    |
    <LT: "<">
    |
    <SUM: "+">
    |
    <SUB: "-">
    |
    <MUL: "*">
    |
    <DIV: "/">
    |
    <NOT: "!">
    |
    <POINT: ".">
    |
    // Special strings
    <MAIN: "main">
    |
    <STRING: "String">
    |
    <LENGTH: "length">
    |
    // Brackets
    <LEFTKEY: "{">
    |
    <RIGHTKEY: "}">
    |
    <LSB: "[">  // Left Square Bracket
    |
    <RSB: "]">  // Right Square Bracket
    |
    <LCB: "(">  // Left Curved Bracket
    |
    <RCB: ")">  // Right Curved Bracket
    |
    // Integer Literal (decimal | hexadecimal | binary)
    <INTEGERLITERAL: (((["+","-"])?(["0"-"9"])+)|("0x"(["0"-"9","a"-"f","A"-"F"])+)|("0b"(["0","1"])+))>
    |
    // Identifier
    <IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])*>
    | <ARR: "@">
}

SimpleNode Start() : {}
{
    WhileStatement()
    {return jjtThis;}
}

// *** Expression
void Expression() #void : {}
{
    Term1() (Op1())*
}

void ExpressionTail() #void : {}
{
    (Op4())* (Op3())* (Op2())* (Op1())*
}

void LiteralExpression() #void : {}
{
    LiteralTerm4() ExpressionTail()
}

void IdentifierExpression() #void : {}
{
    IdentifierTerm4() ExpressionTail()
}

void Term1() #void : {}
{
    Term2() (Op2())*
}

void Term2() #void : {}
{
    Term3() (Op3())*
}

void Term3() #void : {}
{
    Term4() (Op4())*
}

void Term4() #void : {}
{
    (<INTEGERLITERAL> #Integer) (TermTail())*
    |
    (<IDENTIFIER> #Variable) (TermTail())*
    |
    (<TRUE> #True) (TermTail())*
    |
    (<FALSE> #False) (TermTail())*
    |
    (<THIS> #This) (TermTail())*
    |
    (<LCB> Expression() <RCB>) (TermTail())*
    |
    <NEW> NewTerm()
    |
    <NOT> Term4() #NOT(1)
}

void Op1() #void : {}
{
    <AND> Term1() #AND(2)
}

void Op2() #void : {}
{
    <LT> Term2() #LT(2)
}

void Op3() #void : {}
{
    <SUM> Term3() #SUM(2)
    |
    <SUB> Term3() #SUB(2)
}

void Op4() #void : {}
{
    <MUL> Term4() #MUL(2)
    |
    <DIV> Term4() #DIV(2)
}

void TermTail() #void : {}
{
    ArrayAccess()
    |
    ObjectAccess()
}

void ArrayAccess() #void : {}
{
    <LSB> Expression() <RSB> #Bracket(2)
}

void ObjectAccess() #void : {}
{
    <POINT> ObjectAccessTail()
}

void ObjectAccessTail() #void : {}
{
    <LENGTH> #Length(1)
    |
    <IDENTIFIER> #Method ArgumentList() #Call(3)
}

void ArgumentList() : {}
{
    <LCB> (Expression() (<COMMA> Expression())*)? <RCB>
}

void NewTerm() #void : {}
{
    <INT> <LSB> Expression() <RSB> #NewIntArray(1)
    |
    <IDENTIFIER> #Class <LCB> <RCB> #NewClass(1)
}

void LiteralTerm4() #void : {}
{
    (<INTEGERLITERAL> #Integer) (TermTail())*
    |
    (<TRUE> #True) (TermTail())*
    |
    (<FALSE> #False) (TermTail())*
    |
    (<THIS> #This) (TermTail())*
    |
    (<LCB> Expression() <RCB>) (TermTail())*
    |
    <NEW> NewTerm()
    |
    <NOT> Term4() #NOT(1)
}

void IdentifierTerm4() #void : {}
{
    (<IDENTIFIER> #Variable) (TermTail())*
}

// *** Statements
// * Statement Types:
//   * BlockStatement(*)  { ... }
//   * IfElseStatement(3) if (Condition) TrueBranch else ElseBranch
//   * WhileStatement(2)  while (Condition) LoopBody
//   * PlainStatement(1)  Expression
//   * Assignment(2)      Target = Value
void Statement() #void : {}
{
    BlockStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    LineStatement()
}

void BlockStatement() : {}
{
    <LEFTKEY> (Statement())* <RIGHTKEY>
}

void IfElseStatement() : {}
{
    <IF> <LCB> Expression() <RCB> //#Condition(1)
    Statement() //#TrueBranch(1)
    <ELSE> Statement() //#FalseBranch(1)
}

void WhileStatement() : {}
{
    <WHILE> <LCB> Expression() <RCB> //#Condition(1)
    Statement() //#LoopBody(1)
}

void LineStatement() #void : {}
{
    LiteralLineStatement()
    |
    IdentifierStatement()
}

void LiteralLineStatement() #void : {}
{
    LiteralExpression() <SEMICOLON> #PlainStatement(1)
}

void IdentifierStatement() #void : {}
{
    <IDENTIFIER> #Variable
    IdentifierStatementTail() <SEMICOLON> #PlainStatement(1)
}

void IdentifierStatementTail() #void : {}
{
    <EQUAL> Expression() #Assignment(2)
    |
    ArrayAccess() (<EQUAL> Expression() #Assignment(2))?
    |
    ObjectAccess() ExpressionTail()
    |
    ExpressionTail()
}

void LiteralStatement() #void : {}
{
    BlockStatement()
    |
    IfElseStatement()
    |
    WhileStatement()
    |
    LiteralLineStatement()
}
