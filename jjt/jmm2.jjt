options
{
 LOOKAHEAD=1;
 FORCE_LA_CHECK=true;
}

PARSER_BEGIN(jmm)
import java.io.*; 

public class jmm
{
    public static void main(String args[]) throws ParseException,Exception {
        FileReader fr = new FileReader(args[0]);
        jmm myProg = new jmm(fr);
        SimpleNode root = myProg.Start(); // devolve referência para o nó raiz da árvore
        root.dump(""); // imprime no ecrã a árvore
    }
}
PARSER_END(jmm)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

TOKEN: {
    // Keywords
    <PUBLIC: "public">
    |
    <STATIC: "static">
    |
    <CLASS: "class">
    |
    <EXTENDS: "extends">
    |
    <RETURN: "return">
    |
    <IF: "if">
    |
    <ELSE: "else">
    |
    <WHILE: "while">
    |
    <NEW: "new">
    |
    <THIS: "this">
    |
    <TRUE: "true">
    |
    <FALSE: "false">
    |
    // Builtin types
    <VOID: "void">
    |
    <INT: "int">
    |
    <BOOLEAN: "boolean">
    |
    // Operators
    <COMMA: ",">
    |
    <SEMICOLON: ";">
    |
    <EQUAL: "=">
    |
    <AND: "&&">
    |
    <LT: "<">
    |
    <SUM: "+">
    |
    <SUB: "-">
    |
    <MUL: "*">
    |
    <DIV: "/">
    |
    <EXC: "!">
    |
    <POINT: ".">
    |
    // Special strings
    <MAIN: "main">
    |
    <STRING: "String">
    |
    <LENGTH: "length">
    |
    // Brackets
    <LEFTKEY: "{">
    |
    <RIGHTKEY: "}">
    |
    <LSB: "[">  // Left Square Bracket
    |
    <RSB: "]">  // Right Square Bracket
    |
    <LCB: "(">  // Left Curved Bracket
    |
    <RCB: ")">  // Right Curved Bracket
    |
    // Integer Literal (decimal | hexadecimal | binary)
    <INTEGERLITERAL: (((["+","-"])?(["0"-"9"])+)|("0x"(["0"-"9","a"-"f","A"-"F"])+)|("0b"(["0","1"])+))>
    |
    // Identifier
    <IDENTIFIER: ["A"-"Z","a"-"z","$","_"](["0"-"9","A"-"Z","a"-"z","_","$"])*>
}

SimpleNode Start(): {}
{
    ClassDeclaration()
    <EOF>
    {return jjtThis;}
}

void ClassDeclaration(): {}
{
    <CLASS> 
    <IDENTIFIER>
    (<EXTENDS><IDENTIFIER>)?
    <LEFTKEY>
    (ClassVarDeclaration())*
    (ClassMethodDeclaration())*
    <RIGHTKEY>
}

void ClassVarDeclaration(): {}
{
    Type()
    <IDENTIFIER>
    <SEMICOLON>
}

void ClassMethodDeclaration(): {}
{
    <PUBLIC>
    (MainDeclaration() | MethodDeclaration())
}

void MainDeclaration(): {}
{
    <STATIC>
    <VOID>
    <MAIN>
    <LCB>
    MainParameterList()
    <RCB>
    <LEFTKEY>
    (VarThenStatement())?
    <RIGHTKEY>
}

void MethodDeclaration(): {}
{
    <PUBLIC>
    Type()                #MethodReturnType
    <IDENTIFIER>          #MethodName
    <LCB>
    ParameterList()       #MethodParameterList
    <RCB>
    <LEFTKEY>
    (VarThenStatement())? #MethodBody
    <RETURN>
    Expression()
    <SEMICOLON>
    <RIGHTKEY>
}

void MainBody(): {}
{
    (VarThenStatement())?
}

void MethodBody(): {}
{
    (VarThenStatement())?
}

void Parameter(): {}
{
    Type()
    <IDENTIFIER>
}

void ParameterList(): {}
{
    (Parameter() (<COMMA> Parameter())*)?
}

void MainParameterList(): {}
{
    <STRING>
    <LSB>
    <RSB>
    <IDENTIFIER>
}

void PrimitiveType(): {}
{
    IntType() | <BOOLEAN>
}

void ClassType(): {}
{
    <IDENTIFIER>
}

void IntType(): {}
{
    <INT>(<LSB><RSB>)?
}

void Type(): {}
{
    PrimitiveType() | ClassType()
}

void ArrayAccess(): {}
{
    <LSB> Expression() <RSB>
}

void VarThenStatement(): {}
{
    PrimitiveType()VarName() // int a;   int[] b;   boolean c;
    |
    <IDENTIFIER>AssignmentOrDeclaration() // File file;  OR  a = 2;   c = true;
    |
    BlockStatement()(Statement())* // if (c) { return true; }
}

void BlockStatement(): {}
{
    <LEFTKEY>(Statement())*<RIGHTKEY>
    |
    <IF><LCB>Expression()<RCB>Statement()<ELSE>Statement()
    |
    <WHILE><LCB>Expression()<RCB>Statement()
    |
    Expression()<SEMICOLON>
}

void VarName(): {}
{
    <IDENTIFIER><SEMICOLON>(VarThenStatement())?
}

void AssignmentOrDeclaration(): {}
{
    <IDENTIFIER>VarName()
    |
    Assignment()AssignedValue()(Statement())*
}

void Assignment(): {}
{
    (ArrayAccess())?
    <EQUAL>
}

void AssignedValue(): {}
{
    Expression()<SEMICOLON>
}

void Statement(): {}
{
    BlockStatement()
    |
    <IDENTIFIER>Assignment()AssignedValue()
}

void Expression(): {}
{
    <LSB>
}